// Copyright (c) Stride contributors (https://stride3d.net) and Silicon Studio Corp. (https://www.siliconstudio.co.jp)
// Distributed under the MIT license. See the LICENSE.md file in the project root for more information.
shader MotionReconstructionShader : ImageEffectShader
{
    cbuffer PerDraw
    {
        float   u_MinimumThreshold; // gamma
        float   u_MaximumJitter; // eta
        int     u_WeightBias; // K
        int     u_SamplingRate; // N - number of samples
        int     u_JitterLevel; // phi
        int     u_TileSize; // r - number of pixels on one side of the tile
        float   u_ShutterAngle;
        float   u_MotionBlurScale;
    }


    // Texture0: color
    // Texture1: velocity
    // Texture2: depth
    // Texture3: neighborMax
    stage override float4 Shading()
    {
        float2 pos = streams.TexCoord;
        // Color sample at the center point
        const float4 initColor = Texture0.Sample(PointSampler,pos);
        float velocityScale = 50* u_ShutterAngle / 360;
        // Velocity/Depth sample at the center point
        const float3 vdp = SampleVelocityDepth(pos) * velocityScale;
        const float speed = max(length(vdp.xy), 0.5);
        const float rcp_d_p = 1.0 / vdp.z;

        // NeighborMax vector sample at the center point
        const float2 vmax = Texture3.Sample(PointSampler, pos + JitterTile(pos)).xy * velocityScale;
        const float speedVmax = length(vmax);
        const float rcp_speedVmax = 1.0 / speedVmax;

        // Escape early if the NeighborMax vector is small enough.
        if (speedVmax < u_MinimumThreshold) return initColor;

        // Use V_p as a secondary sampling direction except when it's too small
        // compared to vmax. This vector is rescaled to be the length of vmax.
        const float2 v_alt = (speed * 2.0 > speedVmax) ? vdp.xy * (speedVmax / speed) : vmax;

        // Determine the sample count.
        //const float sc = floor(min(u_SamplingRate, speedVmax * 0.5));
        const float sc = float(u_SamplingRate);

        // Loop variables (starts from the outermost sample)
        const float dt = 1.0 / sc;
        const float t_offs = (GradientNoise(pos) - 0.5) * dt;
        float t = 1.0 - dt * 0.5;
        float count = 0.0;

        // Background velocity
        // This is used for tracking the maximum velocity in the background layer.
        float l_v_bg = max(speed, 1.0);

        // Color accumlation
        float4 acc = 0.0;

        [unroll(200)]
        //for(int count = 0; count < sc; count++) 
        while (t > dt * 0.25)
        {
            // Sampling direction (switched per every two samples)
            const float2 v_s = uint(count)%4 == 0 ? v_alt : vmax;

            // Sample position (inverted per every sample)
            const float t_s = (uint(count)%2 == 0 ? -t : t) + t_offs;

            // Distance to the sample position
            const float l_t = speedVmax * abs(t_s);

            // UVs for the sample position
            const float2 uv0 = pos + v_s * t_s * Texture0TexelSize;
            const float2 uv1 = pos + v_s * t_s * Texture1TexelSize;

            // Color sample
            const float3 c = SampleColor(uv0).rgb;

            // Velocity/Depth sample
            const float3 vd = SampleVelocityDepth(uv1) * velocityScale;

            // Background/Foreground separation
            const float fg = saturate((vdp.z - vd.z) * 20.0 * rcp_d_p);

            // Length of the velocity vector
            const float l_v = lerp(l_v_bg, length(vd.xy), fg);

            // Sample weight
            // (Distance test) * (Spreading out by motion) * (Triangular window)
            const float w = saturate(l_v - l_t) / l_v * (1.2 - t);

            // Color accumulation
            acc += float4(c, 1.0) * w;

            // Update the background velocity.
            l_v_bg = max(l_v_bg, l_v);

            // Advance to the next sample.
            t = uint(count)%2==0 ? t - dt : t;
            count += 1.0;
        }

        // Add the center sample.
        //acc += float4(initColor.rgb, 1.0) * (1.2 / (l_v_bg * sc * 2.0));

        return float4(acc.rgb / acc.a, initColor.a);
        //return float4(u_SamplingRate/count,u_SamplingRate/count,u_SamplingRate/count,1);
    }
    float2 SampleVelocity(float2 uv)
    {
        float2 v = Texture1.Sample(PointSampler, uv).xy;
        return float2((v.xy * 2.0 - 1.0) * u_MotionBlurScale);
    }
    float3 SampleVelocityDepth(float2 uv)
    {
        float2 v = Texture1.Sample(PointSampler, uv).xy;
        return float3((v.xy * 2.0 - 1.0) * u_MotionBlurScale, Texture2.Sample(PointSampler,uv).r);
    }
    float3 SampleColor(float2 uv)
    {
        return Texture0.Sample(PointSampler, uv).xyz;
    }

    float zCompare(float a, float b)
    {
        return min(max(0,1-(a-b)/min(a,b)),1);
    }

    float Halton(int b, int i)
    {
        float r = 0.0;
        float f = 1.0;
        while (i > 0) {
            f = f / float(b);
            r = r + f * float(uint(i) % uint(b));
            i = int(floor(float(i) / float(b)));
        }
        return r;
    }
    float2 JitterTile(float2 uv)
    {
        float rx, ry;
        float two_pi = 6.28318530718;
        sincos(GradientNoise(uv + float2(2.0, 0.0)) * two_pi, ry, rx);
        return float2(rx, ry) * Texture3TexelSize* 0.25;
    }
    float2 sOffset(float2 pos, float j)
    {
        float2 randv = random(pos);
        float rsign = randv.x > 0.0 ? -1 : 1;
        float jitter = j * u_MaximumJitter * rsign;
        if(randv.y < 0.5)
        {
            return float2(jitter,0);
        }
        return float2(0,jitter);
    }
    float2 random (float2 st) 
    {
        return frac(sin(dot(st.xy,float2(12.9898,78.233)))*43758.5453123);
    }

    float Cone(in float2 _x, in float2 _y, in float2 _v)
    {
	    return saturate(1.0 - length(_x - _y) / length(_v));
    }

    float Cone(in float _x, in float _y)
    {
	    return saturate(1.0 - _x / _y);
    }

    float Cylinder(in float2 _x, in float2 _y, in float2 _v)
    {
	    float lengthV = length(_v);
	    return 1.0 - smoothstep(0.95 * lengthV, 1.05 * lengthV, length(_x - _y));
    }

    float Cylinder(in float _x, in float _y)
    {
	    return 1.0 - smoothstep(0.95 * _y, 1.05 * _y, _x);
    }

    float SoftStep(in float _a, in float _b, in float _radius)
    {
	    return saturate(1.0 - (_a - _b) / _radius);
    }

    float ZCompare(in float _a, in float _b)
    {
	    return min(1.0, max(0.0, 1.0 - (_a - _b) / min(_a, _b)));
    }
    float2 RNMix(in float2 _a, in float2 _b, in float _theta)
    {
	    return normalize(lerp(_a, _b, _theta));
    }

    float2 random2(float2 st)
    {
        st = float2( dot(st,float2(127.1,311.7)),
                  dot(st,float2(269.5,183.3)) );
        return -1.0 + 2.0*frac(sin(st)*43758.5453123);
    }

    // Gradient Noise by Inigo Quilez - iq/2013
    // https://www.shadertoy.com/view/XdXGW8
    float GradientNoise(float2 st) {
        float2 i = floor(st);
        float2 f = frac(st);

        float2 u = f*f*(3.0-2.0*f);

        return lerp( lerp( dot( random2(i + float2(0.0,0.0) ), f - float2(0.0,0.0) ),
                         dot( random2(i + float2(1.0,0.0) ), f - float2(1.0,0.0) ), u.x),
                    lerp( dot( random2(i + float2(0.0,1.0) ), f - float2(0.0,1.0) ),
                         dot( random2(i + float2(1.0,1.0) ), f - float2(1.0,1.0) ), u.x), u.y);
    }

};
