// Copyright (c) Stride contributors (https://stride3d.net) and Silicon Studio Corp. (https://www.siliconstudio.co.jp)
// Distributed under the MIT license. See the LICENSE.md file in the project root for more information.
shader MotionReconstructionShader : ImageEffectShader
{
    cbuffer PerDraw
    {
        float   u_MinimumThreshold; // gamma
        float   u_MaximumJitter; // eta
        int     u_WeightBias; // K
        int     u_SamplingRate; // N - number of samples
        int     u_JitterLevel; // phi
        int     u_TileSize; // r - number of pixels on one side of the tile
        float   u_MotionBlurScale;
        float   u_MinimumVelocity;
    }


    // Texture0: color
    // Texture1: velocity
    // Texture2: depth
    // Texture3: neighborMax
    stage override float4 Shading()
    {
        // In this pass we should extract 2 speed, the dominant velocity per tiles and the pixel velocity.
        // We will sample color pixels along both speed at different rates depending the length of each speed
        // We will also introduce a bias with the depth texture to remove unwanted blur artifacts


        float2 pos = streams.TexCoord;

        // Getting the current color and the neighborMax texel size
        float2 velocity = Texture1.Sample(PointSampler, pos).xy;

        float2 vmax = (Texture3.Sample(PointSampler, pos).xy * 2.0 - 1.0) * u_MotionBlurScale * Texture3TexelSize;
        if(length(vmax) < u_MinimumVelocity) return Texture0.Sample(PointSampler,pos);
		float2 centerV = (Texture1.Sample(PointSampler, pos).xy * 2.0 - 1.0) * u_MotionBlurScale * Texture1TexelSize;
		float2 Wn = normalize(vmax);
		float2 Wp = float2(-Wn.y, Wn.x);
		if (dot(Wp, centerV) < 0.0)
		{
			Wp = -Wp;
		}
        float y = 1.5;
		float2 Wc = RNMix(Wp, normalize(centerV), (length(centerV) - 0.5) / y);
		float totalWeight = 1.0;//float(u_SamplingRate) / length(centerV) * 1.0;//float(u_SamplingRate);
		float4 centerSample = Texture0.Sample(PointSampler, pos);
		float4 finalColor = float4(centerSample.rgb * totalWeight, centerSample.a);
        [unroll(200)]
		for (int i = 1; i < u_SamplingRate; ++i)
        {
			float t = float(i) / float(u_SamplingRate - 1) - 0.5;

			float2 d = centerV;
            float2 txs = Texture0TexelSize;
			if ((i & 1) == 0)
			{
				d = vmax;
                txs = Texture3TexelSize;
			}
			float T = t * length(vmax);
			float2 sampleP = pos + d * t; // \todo

			float2 sampleV  = (Texture1.Sample(PointSampler, sampleP).xy * 2.0 - 1.0) * u_MotionBlurScale;
			float4 sampleCZ = Texture0.Sample(PointSampler, sampleP);
            float csDepth = Texture2.Sample(PointSampler, pos).r;
            float sampleD = Texture2.Sample(PointSampler, sampleP).r;
			float foreground = ZCompare(csDepth, sampleD); 
			float background = ZCompare(sampleD, csDepth);

			float weightA = dot(Wc, d);
			float weightB = dot(normalize(sampleV), d);

			float weight = 0.0;
			weight += foreground * Cone(T, 1.0 / length(sampleV)) * weightB;
			weight += background * Cone(T, 1.0 / length(centerV)) * weightA;
			weight += Cylinder(T, min(length(sampleV), length(centerV))) * max(weightA, weightB) * 2.0;
			

			totalWeight += weight;
			finalColor += float4(sampleCZ.rgb * weight,finalColor.w);
		}
		finalColor.rgb /= totalWeight;
        return finalColor;
    }

    float zCompare(float a, float b)
    {
        return min(max(0,1-(a-b)/min(a,b)),1);
    }

    float Halton(int b, int i)
    {
        float r = 0.0;
        float f = 1.0;
        while (i > 0) {
            f = f / float(b);
            r = r + f * float(uint(i) % uint(b));
            i = int(floor(float(i) / float(b)));
        }
        return r;
    }
    float2 sOffset(float2 pos, float j)
    {
        float2 randv = random(pos);
        float rsign = randv.x > 0.0 ? -1 : 1;
        float jitter = j * u_MaximumJitter * rsign;
        if(randv.y < 0.5)
        {
            return float2(jitter,0);
        }
        return float2(0,jitter);
    }
    float2 random (float2 st) 
    {
        return frac(sin(dot(st.xy,float2(12.9898,78.233)))*43758.5453123);
    }

    float Cone(in float2 _x, in float2 _y, in float2 _v)
    {
	    return saturate(1.0 - length(_x - _y) / length(_v));
    }

    float Cone(in float _x, in float _y)
    {
	    return saturate(1.0 - _x / _y);
    }

    float Cylinder(in float2 _x, in float2 _y, in float2 _v)
    {
	    float lengthV = length(_v);
	    return 1.0 - smoothstep(0.95 * lengthV, 1.05 * lengthV, length(_x - _y));
    }

    float Cylinder(in float _x, in float _y)
    {
	    return 1.0 - smoothstep(0.95 * _y, 1.05 * _y, _x);
    }

    float SoftStep(in float _a, in float _b, in float _radius)
    {
	    return saturate(1.0 - (_a - _b) / _radius);
    }

    float ZCompare(in float _a, in float _b)
    {
	    return min(1.0, max(0.0, 1.0 - (_a - _b) / min(_a, _b)));
    }
    float2 RNMix(in float2 _a, in float2 _b, in float _theta)
    {
	    return normalize(lerp(_a, _b, _theta));
    }
};
